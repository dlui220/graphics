* Graphics Notes
** 2/4/16
*** NetPBM
**** Header
***** P3
***** <XRES> <YRES>
***** <MAX COLOR VALUE>
**** R_G_B   R G B   RGB
**** All whitespace is equivalent
** 2/5/16
*** Bresenham's Line Algorithm
**** y = mx + b
**** y = [delta(y) / delta(x)]x + b
**** y*delta(x) = x*delta(y) + b*delta(x)
***** multiply by delta(x)
**** 0 = x*delta(y) - y*delta(x) + b*delta(x)
***** A = delta(y)
***** B = -delta(x)
***** C = b*(delta(x))
**** 0 = Ax + By + C

**** f(x,y) = Ax + By + C
*****       = 0 -> (x,y) is on the line
*****       < 0 -> (x,y) is above the line
*****       > 0 -> (x,y) is below the line

**** Assume first octant (more horizontal than vertical)
***** Midpoint: (x+1, y+1/2)
***** f(x+1,y+1/2)
****** = 0 midpoint is on the line, either point is ok
****** < 0 mp is above, draw (x+1,y)
****** > 0 mp is below, draw (x+1, y+1)
** 2/9/16
*** Bresenham's Line Algorithm (continued)
**** First Draft Algorithm
#+NAME: <1st Draft Algorithm>
#+BEGIN_SRC 
(x0,y0) -> (x1,y1)
x = x0   ,  y = y0

while (x <= x1):
   plot(x,y)
   d = F(x+1,y+1/2)
   if(d < 0):
      y = y + 1
   x = x + 1
#+END_SRC
***** Initial value of d
****** d = f(x0+1,y0+1/2)
****** d = A(x0+1) + B(y0+1/2) + C
****** d = Ax0 + A + By + (1/2)B + C
****** d = Ax0 + By0 + C + A + (1/2)B
*******   |   F(x0,y0)  |
******                 0 + A + (1/2)B
****** d = A + (1/2)B
**** Second Draft Algorithm
#+NAME: <2nd Draft Algorithm>
#+BEGIN_SRC 
(x0,y0) -> (x1,y1)
x = x0   ,  y = y0
d = A + (1/2)B

while (x < x1):
   plot(x,y)
   if(d > 0):
      y +=  1
   x += 1
   d = F(x+1,y+1/2)
#+END_SRC
**** If d > 0:
***** x -> x+1 , y -> y+1
***** d = f(x+1,y+1)
***** d = d + A + B
**** If d < 0:
***** x -> x+1 , y -> y
***** d = f(x+1,y)
***** d = d + A
**** Third Draft Algorithm
***** Minimize functions, reduce amount of times we multiply
***** Function for Octant 1
#+NAME: <3rd Draft Algorithm>
#+BEGIN_SRC 
(x0,y0) -> (x1,y1)
x = x0   ,  y = y0
d = A + (1/2)B

while (x < x1):
   plot(x,y)
   if(d > 0):
      y +=  1
      d += B
   x += 1
   d += A
#+END_SRC
** 2/10/16
*** Octant I Algorithm
**** Get rid of the 1/2
#+NAME: <Algorithm>
#+BEGIN_SRC 
(x0,y0) -> (x1,y1)
x = x0   ,  y = y0
A = y1-y0, B = -(x1-x0), d = 2A+B

while (x < x1):
   plot(x,y)
   if(d > 0):
      y +=  1
      d += 2B
   x += 1
   d += 2A
#+END_SRC
*** Octant II
**** 1 < m < infinity
***** Going up more often than to the right
**** Possible pixels
***** (x,y+1)
***** (x+1,y+1)
**** Midpoint: (x+1/2, y+1)
**** Initial d
***** f(x0+1/2,y0+1)
***** Ax0 + By0 + C + 1/2A + B
****** d = 1/2 A + B
***** If f(x,y):
****** < 0, (x,y) to the left
****** > 0, (x,y) to the right
***** Test:
****** If d > 0, draw (x,y+1)
****** If d < 0, draw (x+1,y+1)
**** Algorithm

#+NAME: <Algorithm>
#+BEGIN_SRC 
(x0,y0) -> (x1,y1)
x = x0   ,  y = y0
A = y1-y0, B = -(x1-x0), d = 1A+2B

while (y <= y1):
   plot(x,y)
   if(d < 0):
      x +=  1
      d += 2A
   y += 1
   d += 2B
#+END_SRC
*** Octant VIII
**** -1 < m < 0
**** Possible
***** (x+1,y-1)
***** (x+1,y)
**** Midpoint (x+1,y-1/2)
** 2/23/16
*** Matrix Math Review
**** Scalar Multiplication
***** Multiplying a matrix by a constant number
***** Multiply each number in the matrix by the scalar
**** Matrix Multiplication
***** Not commutative
****** M0 * M1 =/= M1 * M0
****** # of columns in M0 = # of rows in M1
**** Multiplicative Identity Matrix
***** Always a square
***** Diagonal of 1's
***** 0's everywhere else
**** Matrices in Graphics
***** Scaling
****** (x,y,z) --S(a,b,c)--> (ax,by,cz)
****** Multiply by a scale matrix
****** Identity matrix with (a,b,c) as diagonal
** 2/24/16
*** Transformation Matrices
**** Scaling
***** (x,y,z) --s(a,b,c)--> (ax,by,cz)
a 0 0 0     x     ax
0 b 0 0     y     by
0 0 c 0  *  z  =  cz
0 0 0 1     1     1
**** Translating
***** (x,y,z) --T(a,b,c)--> (a+x,b+y,c+z)
***** We need the 1 at the end of the matrix for translations
1 0 0 a     x     a+x
0 1 0 b     y     b+y
0 0 1 c  *  z  =  c+z
0 0 0 1     1     1
**** Rotating
***** (x,y,z) --(R z-axis, theta)--> 
***** (xcos(theta)-ysin(theta), ycos(theta)+xsin(theta), z)
****** x = rcos theta
****** y = rsin phi
****** x_r = rcos( phi + theta )
****** y_r = rsin( phi + theta )
****** x_r = rcos(phi)cos(theta) - rsin(phi)sin(theta)
****** x_r = xcos(theta) - ysin(theta)
****** y_r = rcos(theta)sin(phi) + rsin(theta)cos(phi)
****** y_r = ycos(theta) + xsin(theta)
***** Matrix for Z rotation
cos(theta)  -sin(theta)  0  0     x     xcos(theta) - ysin(theta)
sin(theta)   cos(theta)  0  0  *  y  =  ycos(theta) + xsin(theta)
0            0           1  0     z                 z
0            0           0  1     1                 1
***** (x,y,z) --(R x-axis, theta)--> 
***** (x, ycos(theta)-zsin(theta), ysin(theta)+zcos(theta))
***** Matrix for X rotation
x     y             z       1
1     0             0       0
0  cos(theta)  -sin(theta)  0
0  sin(theta)   cos(theta)  0
0     0             0       1
***** (x,y,z) --(R y-axis, theta)-->
***** (xcos(theta)-zsin(theta), y, xsin(theta)+zcos(theta))
***** Matrix for Y rotation
cos(theta)  0  -sin(theta)  0
     0      1       0       0 
sin(theta)  0   cos(theta)  0 
     0      0       0       1
** 2/25/16
*** Applying transformations
**** E0: edge, T: translation, S: scale, R: rotation
***** T * E0 = E1: translated
***** S * E1 = E2: translated, then scaled
***** R * E2 = E3: translated, then scaled, then rotated
